services:
  app:
    build:
      context: ..
      dockerfile: docker/Dockerfile
    container_name: app
    restart: always
    working_dir: /workspace
    # Graceful shutdown: give application time for correct termination (15 seconds)
    # Application has total_shutdown = 5 seconds, but add margin for reliability
    stop_grace_period: 15s
    volumes:
      - ..:/workspace
      - ./supervisord.conf:/etc/supervisor/conf.d/supervisord.conf:ro
    environment:
      - ENVIRONMENT=${ENVIRONMENT:-dev}
      - PYTHONUNBUFFERED=1
      - PYTHONDONTWRITEBYTECODE=1
    # Launch via Supervisor for automatic process restart on crash
    command: /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf
    # depends_on removed from base file - dependencies defined in environment files (test/prod)

  postgres:
    image: pgvector/pgvector:pg18
    container_name: postgres
    restart: always
    # Do NOT specify user: postgres - standard entrypoint manages user itself
    # It runs as root, fixes directory permissions (if needed) and switches to postgres
    # This allows automatic DB initialization on first installation
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-core_db}
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-coreness1234}
      PGDATA: /var/lib/postgresql/data
    volumes:
      - ../data/postgresql:/var/lib/postgresql/data
      # Initialization script for automatic pgvector extension installation
      - ./init-pgvector.sql:/docker-entrypoint-initdb.d/01-init-pgvector.sql:ro
      # PostgreSQL configuration mounted in environments (test/prod)
    # Ports forwarded in environment files (test/prod)
    # Test: 5433:5432, Prod: 5432:5432
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres}"]
      interval: 10s
      timeout: 5s
      retries: 5
    # Use standard PostgreSQL entrypoint
    # IMPORTANT: For bind mount, directory permissions on host cannot be changed from container
    # Standard entrypoint runs as root and can create files with correct permissions inside directory
    # But if directory on host belongs to root and is not empty, there may be problems
    # SOLUTION: Before first run on host execute:
    #   rm -rf <project_path>/data/postgresql  # Remove empty directory
    #   # Or fix permissions:
    #   chown -R 999:999 <project_path>/data/postgresql
    #   chmod 700 <project_path>/data/postgresql
    # Standard entrypoint runs as root, initializes DB if directory is empty, then switches to postgres
    # Custom configs applied via postgres command line parameters (if exist)
    entrypoint: ["/bin/bash", "-c"]
    command:
      - |
        # Fix directory permissions before check (in case they're incorrect)
        # This is needed so standard entrypoint can read PG_VERSION
        if [ -d /var/lib/postgresql/data ]; then
          chown -R postgres:postgres /var/lib/postgresql/data 2>/dev/null || true
          chmod 700 /var/lib/postgresql/data 2>/dev/null || true
        fi
        # Apply custom configs only if they exist
        # Standard entrypoint will check for PG_VERSION and initialize DB if needed
        if [ -f /etc/postgresql/postgresql.conf ] && [ -s /etc/postgresql/postgresql.conf ] && [ -f /etc/postgresql/pg_hba.conf ] && [ -s /etc/postgresql/pg_hba.conf ]; then
          exec docker-entrypoint.sh postgres -c config_file=/etc/postgresql/postgresql.conf -c hba_file=/etc/postgresql/pg_hba.conf
        elif [ -f /etc/postgresql/postgresql.conf ] && [ -s /etc/postgresql/postgresql.conf ]; then
          exec docker-entrypoint.sh postgres -c config_file=/etc/postgresql/postgresql.conf
        else
          exec docker-entrypoint.sh postgres
        fi

